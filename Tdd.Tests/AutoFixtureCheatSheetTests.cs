using Ploeh.AutoFixture;
using System;
using System.Collections.Generic;
using System.Linq;
using TddTests;
using Xunit;
using Xunit.Abstractions;

namespace Tdd.Tests
{
    public class AutoFixtureCheatSheetTests : IDisposable
    {
        private readonly ITestOutputHelper output;
        private Fixture Fixture { get; set; }

        public AutoFixtureCheatSheetTests(ITestOutputHelper output)
        {
            this.output = output;
            Fixture = new Fixture();
        }

        public void Dispose()
        {
        }

        public void OutputEnumerable<T>(IEnumerable<T> anyEnumerable)
        {
            foreach (var t in anyEnumerable)
                output.WriteLine("Element: {0}", t);
        }

        [Fact]
        public void AutogeneratedString()
        {
            var sut = Fixture.Create<string>(); // The algorithm is simply to create a new Guid and convert it to a string.
            output.WriteLine("AutoFixtureCheatSheetTests.AutogeneratedString(): {0}", sut);
            Assert.IsType(typeof(string), sut);
        }

        [Fact]
        public void AutogeneratedStringWithSeed()
        {
            var sut = Fixture.Create("Name"); // This is still going to create a Guid, but will now prepend the seed.
            output.WriteLine("AutoFixtureCheatSheetTests.AutogeneratedStringWithSeed(): {0}", sut);
            Assert.StartsWith("Name", sut);
        }

        /// <summary>
        /// The first numbers are generated within the range of [1, 255] => Byte
        /// When the first 255 integers have been used, numbers are subsequently picked from the range [256, 32767] => Int16
        /// etc.
        /// </summary>
        [Fact]
        public void AutogeneratedNumber()
        {
            var sut = Fixture.Create<int>();
            output.WriteLine("AutoFixtureCheatSheetTests.AutogeneratedNumber(): {0}", sut);
            Assert.IsType(typeof(int), sut);
        }

        [Fact]
        public void AutogeneratedClass()
        {
            var sut = Fixture.Create<Bar>();
            output.WriteLine("AutoFixtureCheatSheetTests.AutogeneratedClass()");
            output.WriteLine("Bar");
            output.WriteLine(" First Name: {0}", sut.FirstName);
            output.WriteLine(" Middle Name: {0}", sut.MiddleName);
            output.WriteLine(" Last Name: {0}", sut.LastName);
            output.WriteLine(" Age: {0}", sut.Age);
            Assert.IsType(typeof(Bar), sut);
            Assert.IsType(typeof(string), sut.FirstName);
            Assert.IsType(typeof(byte), sut.Age);
        }

        [Fact]
        public void AnonymousSequences()
        {
            var sut = Fixture.CreateMany<string>().ToList();  // By default, these methods all create 3 anonymous variables

            OutputEnumerable(sut);

            Assert.Equal(3, sut.Count);
        }

        [Fact]
        public void AddAnonymousItemsToList()
        {
            var list = new List<int>() {5, 3, 7};
            var r = new Random();
            Fixture.RepeatCount = 6;
            Fixture.AddManyTo(list, () => r.Next());
            OutputEnumerable(list);

            Assert.Equal(9, list.Count);
        }

        [Fact]
        public void SettingPropertiesValues()
        {
            var bar = Fixture.Build<Bar>()
                .With(b => b.FirstName, "John")
                .With(b => b.LastName, "Doe")
                .Create();

            Assert.Equal("Doe", bar.LastName);
        }

        [Fact]
        public void AutogeneratedClassWithConstructorValues()
        {
            var sut = Fixture.Build<Bar>()
                .OmitAutoProperties()
                .Create();

            output.WriteLine("First Name: {0}", sut.FirstName);
            output.WriteLine("Middle Name: {0}", sut.MiddleName);
            output.WriteLine("Last Name: {0}", sut.LastName);
            output.WriteLine("Age: {0}", sut.Age);

            Assert.Equal("Smith", sut.LastName);
        }
    }
}
